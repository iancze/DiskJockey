<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cookbook · DiskJockey.jl Documentation</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-5472810-7', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="DiskJockey.jl Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit">DiskJockey.jl Documentation</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="dynamical_mass_intro.html">Introduction</a></li><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="conventions.html">Conventions</a></li><li><a class="tocitem" href="models.html">Models</a></li><li><a class="tocitem" href="formats.html">Formats</a></li><li><a class="tocitem" href="RADMC3D_setup.html">RADMC Setup</a></li><li class="is-active"><a class="tocitem" href="cookbook.html">Cookbook</a><ul class="internal"><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Makefile"><span>Makefile</span></a></li><li><a class="tocitem" href="#Plotting-up-the-model-structure"><span>Plotting up the model structure</span></a></li><li><a class="tocitem" href="#Synthesizing-a-model-image"><span>Synthesizing a model image</span></a></li><li><a class="tocitem" href="#Setting-up-a-parallelized-MCMC-exploration-of-the-parameters"><span>Setting up a parallelized MCMC exploration of the parameters</span></a></li><li><a class="tocitem" href="#Launching-the-run"><span>Launching the run</span></a></li><li><a class="tocitem" href="#Examining-the-output"><span>Examining the output</span></a></li></ul></li><li><a class="tocitem" href="priors.html">Priors</a></li><li><a class="tocitem" href="api.html">API</a></li><li><a class="tocitem" href="changelog.html">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="cookbook.html">Cookbook</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="cookbook.html">Cookbook</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/iancze/DiskJockey/blob/master/docs/src/cookbook.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cookbook"><a class="docs-heading-anchor" href="#Cookbook">Cookbook</a><a id="Cookbook-1"></a><a class="docs-heading-anchor-permalink" href="#Cookbook" title="Permalink"></a></h1><p>After you have installed <code>DiskJockey</code>, it&#39;s time to get up and running!</p><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><p>Now the <code>DiskJockey</code> package should be successfully installed user-wide. Because it is likely that you will want to fit more than just one protoplanetary disk, or perhaps try different model specifications for a particular disk, the code structure is organized so that you will have a separate directory for each disk model. The following is an example to get you started fitting AK Sco.</p><pre><code class="language-none">$ mkdir AKSco
$ cd AKSco</code></pre><p>Make sure to download the dataset in HDF5 format <a href="https://figshare.com/articles/ALMA_AK_Sco_12CO_J_2_1_Visibilities/2066022">here</a>.</p><p>Now, you&#39;ll want to initialize this directory with a config file. This config file will store all of the options that are specific to fitting this disk and is frequently used by many of the scripts in this package. To initialize,</p><pre><code class="language-none">$ DJ_initialize.jl --new-project=standard
Copied default config.yaml, InitializeWalkers.ipynb, and Makefile for the standard model to current working directory.
Exiting</code></pre><p><code>--new-project</code> also has other than <code>standard</code>, such as <code>cavity</code> and <code>vertical</code> in order to fit more exotic models. Now, open up <code>config.yaml</code> with your favorite text editor and change the fields as you see fit, including which transition of CO you would like to fit. Currently (v0.1.3), this package only includes functionality for 12CO, 13CO, and C18O in LTE. Please create an issue on the github repository if you would like a new species added.</p><p>To help get you started, here are some reasonable fields for the <code>config.yaml</code> file for AK Sco:</p><p>General synthesis parameters:</p><pre><code class="language-none">name: AKSco
gas: true
species : 12CO # Possible choices: 12CO, 13CO, C18O. Future may include HCN, etc...
transition: 2-1 # J =</code></pre><p>The model grid setup:</p><pre><code class="language-none">grid:
  nr: 128
  ntheta: 40 # if mirrored about the equator, total of 80
  nphi: 1
  r_in: 0.1 # [AU] # Inner edge of model grid
  r_out: 300. # [AU] # Outer edge of model grid</code></pre><p>The distance parameters. For now, we will keep distance fixed:</p><pre><code class="language-none">fix_params : [&quot;dpc&quot;]</code></pre><p>Even though we are keeping the distance fixed, we need to specify these prior parameters:</p><pre><code class="language-none">dpc_prior:
	mu: 142.
	sig: 20.</code></pre><p>Choose what type of model will we be fitting:</p><pre><code class="language-none">model : standard # choices of {standard, truncated, vertical, cavity, etc..}</code></pre><p>Now come parameters that can be used to synthesize and plot models. Due to a quirk of how YAML files are read, make sure that each of these parameter values is a float and not an int (i.e., <code>1.0</code> vs. <code>1</code>).</p><pre><code class="language-none">parameters:
  M_star: 2.49 # [M_sun] stellar mass
  r_c: 14.00 # [AU] characteristic radius
  T_10: 91.85 # [K] temperature at 10 AU
  q: 0.51 # temperature gradient exponent
  gamma: 1.0 # surface density gradient
  logSigma_c: 3.0 # log surface density at char. radius
  ksi: 0.31 # [km/s] microturbulence
  dpc: 142. # [pc] distance
  incl: 109.4 # [degrees] inclination
  PA: 141.1 # [degrees] position angle
  vel: -26.1 # [km/s]
  mu_RA: 0.053 # [arcsec] centroid location
  mu_DEC: 0.045 # [arcsec]</code></pre><p>Of all of these parameters, it might be hardest to guess correctly at the systemic velocity of the source. Generally, this is best done in the data reduction stages, for example taking a quick look at the central frequency of the spectral line. Note that the AK Sco dataset is provided in the raw <em>topocentric</em> frame, so the velocity quoted here is not the same as the LSRK quoted in the paper.</p><p>Now, we need to specify how big we want our image to be and how many pixels it should have.</p><pre><code class="language-none"># Image setup
size_arcsec : 12.0 # [arcsec] full width/height of image
npix: 512</code></pre><p>The final section is parameters that roughly describe the RMS in the observation and the approximate beam size. These parameters are only used in the channel map plotting script to help make the channel maps look more comparable to the observation, and you don&#39;t need to worry about them now.</p><pre><code class="language-none">beam :
  rms : 0.01 # Jy/beam
  BMAJ: 0.9 # arcsec # Major axis of ellipse
  BMIN: 0.9 # arcsec # Minor axis of ellipse
  BPA: 1.0 # degrees east of North of the semi-major axis.</code></pre><p>Now, a good thing to check is that our setup parameters actually satisfy the Nyquist theorem. There is a helper script for this</p><pre><code class="language-none">$ max_baseline.jl
Dataset channels are velocities from -10.517295788189767 to -42.656605289812504 and span -32.13930950162273 km/s.
Midpoint is -26.586950539001137 km/s.
Max baseline 338.5121039138373 kilolambda
Nyquist sampling satisfied. dRA: 0.0234375 [arcsec/pix] ; dRA_max: 0.2769671424693894 [arcsec/pix]
Image size satisfied. Image size at the closest distances: 510.0 [AU]; outer radius of the grid + 10%: 330.0 [AU]</code></pre><p>It looks like everything is OK to start!  (If you see very different velocities here for the channels, check that you have correctly specified <code>species</code> and <code>transition</code> in <code>config.yaml</code> to match the spectral line actually observed in your dataset.) </p><h2 id="Makefile"><a class="docs-heading-anchor" href="#Makefile">Makefile</a><a id="Makefile-1"></a><a class="docs-heading-anchor-permalink" href="#Makefile" title="Permalink"></a></h2><p>New in v0.1.3, I&#39;ve written a Makefile which should simplify a lot of the necessary tasks within the directory for a single object. You can generally do everything you need to via <code>make &lt;target&gt;</code>, where the various targets will now be described.</p><h2 id="Plotting-up-the-model-structure"><a class="docs-heading-anchor" href="#Plotting-up-the-model-structure">Plotting up the model structure</a><a id="Plotting-up-the-model-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-up-the-model-structure" title="Permalink"></a></h2><p>To get a first pass glimpse at what the model will look like, you can make plots of the key quantities as a function of disk position.</p><pre><code class="language-none">$ make structure</code></pre><p>will create plots in your current working directory of velocity, temperature, and surface density. If want to play around with this, change a parameter in <code>config.yaml</code> and then rerun <code>make structure</code></p><p><img src="temperature.png" alt="Temperature"/></p><p><img src="surface_density.png" alt="Surface Density"/></p><p><img src="velocity.png" alt="Velocity"/></p><h2 id="Synthesizing-a-model-image"><a class="docs-heading-anchor" href="#Synthesizing-a-model-image">Synthesizing a model image</a><a id="Synthesizing-a-model-image-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesizing-a-model-image" title="Permalink"></a></h2><p>Before jumping into running any MCMC chains, it is a good idea to take a guess at some parameters and try synthesizing a set of model channel maps to see if your model looks remotely close to the dataset. Then, you can play around with values in <code>config.yaml</code> to see what works well.</p><p>To jump right in, just try</p><pre><code class="language-none">$ make chmaps</code></pre><p>And the code will start synthesizing channel maps. Because the AK Sco dataset contains a lot of channels, this may take about 5 minutes to get everything done. During this process, the output from RADMC-3D is piped to <code>STDOUT</code>. This may be a good place to debug if anything looks fishy.</p><p>When complete, this should leave you with several <code>chmaps_*.png</code> files in your current directory. Take a look and see if these appear reasonable.</p><p>For me, a typical workflow for playing around with channel maps is</p><ol><li>edit <code>config.yaml</code> to parameters that might make sense</li><li>run <code>make structure</code> to see that the disk properties look reasonable</li><li>run <code>make chmaps</code> to actually synthesize images</li><li>inspect the resulting plots of the data (<code>chmaps_linear.png</code>), and if I am not satisfied go back to 1</li></ol><p>It is a very good idea to inspect your channel maps to make sure that there isn&#39;t any weird structure, that you have enough pixels to resolve the disk structure, and that your model grid appears to be at high enough resolution. <strong>A few extra minutes or hours spent debugging your images during this step can save you days (of supercomputer time) in the steps ahead.</strong></p><p><img src="chmaps_hires_linear.png" alt="High Resolution Image of AK Sco"/></p><p>If you&#39;d like to make a spatially-integrated spectrum, you can also do</p><pre><code class="language-none">$ make spectrum.png</code></pre><p><img src="spectrum.png" alt="Spectrum of AK Sco"/></p><h2 id="Setting-up-a-parallelized-MCMC-exploration-of-the-parameters"><a class="docs-heading-anchor" href="#Setting-up-a-parallelized-MCMC-exploration-of-the-parameters">Setting up a parallelized MCMC exploration of the parameters</a><a id="Setting-up-a-parallelized-MCMC-exploration-of-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-parallelized-MCMC-exploration-of-the-parameters" title="Permalink"></a></h2><p>As you just experienced, model synthesis can take a very long time, generally 1 - 5 minutes per model in the case of AK Sco. In order to explore the posterior in a reasonable amount of time, we need to parallelize the synthesis and evaluation of the likelihood function across multiple compute cores. This is done using a Julia port of the Ensemble Sampler by Goodman and Weare 2010, implemented in Python by Foreman-Mackey et al. as <code>emcee</code>. For more information about this great sampler, see <a href="http://dan.iel.fm/emcee/current/">here</a>.</p><p>Much like <code>emcee</code>, starting out requires deciding upon the positions of the walkers. To aid in placing these, the <code>DJ_initialize.jl</code> script copied over a Jupyter/Python notebook to your current directory. Now, open up <code>InitializeWalkers.ipynb</code> with a Jupyter notebook. We will change these following values to correspond to your disk of choice.</p><p>To save you some computational time otherwise spent on burn-in, I found that the following walker starting positions worked well for AK Sco</p><pre><code class="language-none">p0 = np.array([np.random.uniform(2.4, 2.5, nwalkers), # mass [M_sun]
          np.random.uniform(14., 15.0, nwalkers), #r_c [AU]
          np.random.uniform(92., 93., nwalkers), #T_10 [K]
          np.random.uniform(0.51, 0.55, nwalkers), # q
          np.random.uniform(-3.5, -3.4, nwalkers), #log10 M_gas [log10 M_sun]
          np.random.uniform(0.3, 0.32, nwalkers), #xi [km/s]
          np.random.uniform(140.0, 144.0, nwalkers), #dpc [pc]
          np.random.uniform(110.0, 112.0, nwalkers), #inc [degrees]
          np.random.uniform(140.0, 141.0, nwalkers), #PA [degrees]
          np.random.uniform(-26.1, -26.0, nwalkers), #vz [km/s]
          np.random.uniform(0.0, 0.05, nwalkers), #mu_a [arcsec]
          np.random.uniform(0.0, 0.4, nwalkers)]) #mu_d [arcsec]</code></pre><p>Then finish evaluating the rest of the cells so that you save the file <code>pos0.npy</code> into your current working directory.</p><p>How many walkers should you use? Due the the way the Ensemble Sampler advances, you can only evaluate half of the walkers simultaneously. That means that if you are running with more cores than <code>nwalkers/2</code>, you will have several cores idle throughout the sampling. Of course, you could now increase the number of walkers to be <code>2 * ncores</code>.</p><h2 id="Launching-the-run"><a class="docs-heading-anchor" href="#Launching-the-run">Launching the run</a><a id="Launching-the-run-1"></a><a class="docs-heading-anchor-permalink" href="#Launching-the-run" title="Permalink"></a></h2><p>The exploration of the posterior is done via the <code>scripts/venus.jl</code> script. It is worth exploring this piece of code to see the various moving parts. How you invoke this script depends on your cluster environment. For a dataset the size of AK Sco, it&#39;s not worth your time to start run this script (except for debugging purposes) unless you have access to 20 or more cores.</p><h3 id="Local-machine-with-20-cores"><a class="docs-heading-anchor" href="#Local-machine-with-20-cores">Local machine with 20 cores</a><a id="Local-machine-with-20-cores-1"></a><a class="docs-heading-anchor-permalink" href="#Local-machine-with-20-cores" title="Permalink"></a></h3><p>If you have your own 20-core machine, you can launch the script via  </p><pre><code class="language-none">$ venus.jl -p 19</code></pre><p>Much like the Julia interpreter itself, the <code>-p</code> argument will add an addition 19 workers to the master process for a total of 20 workers.</p><h3 id="High-Performance-Cluster"><a class="docs-heading-anchor" href="#High-Performance-Cluster">High Performance Cluster</a><a id="High-Performance-Cluster-1"></a><a class="docs-heading-anchor-permalink" href="#High-Performance-Cluster" title="Permalink"></a></h3><p>These Julia scripts can take advantage many possible cores spread across multiple nodes. This may require some custom script writing for your specific cluster situation, but the main ideas are as follows</p><ol><li><p>write a submission script that specifies total number of cores, time, memory, etc</p></li><li><p>upon submission, determine how many cores you have been allocated on which nodes</p></li><li><p>create a hosts.txt file which contains this information, following the Julia spec here.</p></li><li><p>then start your job with</p><p>julia –machinefile hosts.txt venus.jl</p></li></ol><h2 id="Examining-the-output"><a class="docs-heading-anchor" href="#Examining-the-output">Examining the output</a><a id="Examining-the-output-1"></a><a class="docs-heading-anchor-permalink" href="#Examining-the-output" title="Permalink"></a></h2><p>Because the MCMC run is so expensive, the code is designed to periodically write out snapshots of the samples, to both save your progress and allow you to check up on the chains mid-run. You can set the cadence in the <code>config.yaml</code> file under</p><pre><code class="language-none"># MCMC setup
samples: 10
loops: 1</code></pre><p>Basically, in each <code>loop</code>, the code advances <code>N</code> <code>samples</code>. After each loop, the full chain (<code>chain.npy</code>) is written to the <code>output/</code> directory along with a current snapshot of the walker positions, <code>pos0.npy</code>. This way if your <code>venus.jl</code> script ends (either by design or cluster failure), you can copy this <code>pos0.npy</code> back to your project directory and start from the last known walker positions.</p><p>At this point you can take the samples in <code>chain.npy</code> and analyze them as you would normal MCMC samples. To save you the trouble, however, we included a script to help with these tasks</p><pre><code class="language-none">$ plot_walkers.py</code></pre><p>will plot the walker positions as a function of iteration (<code>walkers.png</code>). Examining <code>walkers.png</code> is a decent way to estimate if your chains are done with burn-in.</p><p>When you are ready, you can burn off these first say 300 (or more) iterations and make a corner plot (<code>triangle.png</code>) by</p><pre><code class="language-none">$ plot_walkers.py --burn 300 --tri</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="RADMC3D_setup.html">« RADMC Setup</a><a class="docs-footer-nextpage" href="priors.html">Priors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 25 April 2021 14:49">Sunday 25 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
